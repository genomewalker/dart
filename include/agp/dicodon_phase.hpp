#pragma once

/**
 * @file dicodon_phase.hpp
 * @brief Unified interface for dicodon phase hexamer scoring
 *
 * Provides frame-discriminative scoring using phase-specific hexamer frequencies.
 * Unlike regular hexamers that only distinguish "coding vs non-coding", dicodon
 * phase hexamers capture FRAME INFORMATION by tracking hexamers at codon positions
 * 0, 1, and 2.
 *
 * Frame discrimination logic:
 * - Phase 0: hexamers at true codon boundaries (most frame-discriminative)
 * - Phase 1: hexamers offset by 1 from codon boundary
 * - Phase 2: hexamers offset by 2 from codon boundary
 *
 * For a sequence being tested in frame F:
 * - Position i in the sequence corresponds to phase (i - F) mod 3
 * - A true coding sequence should have hexamers matching their expected phase
 */

#include <cstdint>
#include <cmath>
#include <string>
#include "agp/hexamer_tables.hpp"  // For Domain enum and encode_hexamer

// Include domain-specific tables (generated by extract_dicodon_phase_hexamers)
// Note: Some may not exist yet - guard with #if __has_include
#if __has_include("agp/gtdb_dicodon_phase.hpp")
#include "agp/gtdb_dicodon_phase.hpp"
#define HAS_GTDB_DICODON 1
#endif

#if __has_include("agp/fungi_dicodon_phase.hpp")
#include "agp/fungi_dicodon_phase.hpp"
#define HAS_FUNGI_DICODON 1
#endif

#if __has_include("agp/viral_dicodon_phase.hpp")
#include "agp/viral_dicodon_phase.hpp"
#define HAS_VIRAL_DICODON 1
#endif

#if __has_include("agp/plant_dicodon_phase.hpp")
#include "agp/plant_dicodon_phase.hpp"
#define HAS_PLANT_DICODON 1
#endif

#if __has_include("agp/protozoa_dicodon_phase.hpp")
#include "agp/protozoa_dicodon_phase.hpp"
#define HAS_PROTOZOA_DICODON 1
#endif

#if __has_include("agp/invertebrate_dicodon_phase.hpp")
#include "agp/invertebrate_dicodon_phase.hpp"
#define HAS_INVERTEBRATE_DICODON 1
#endif

#if __has_include("agp/vertebrate_mammalian_dicodon_phase.hpp")
#include "agp/vertebrate_mammalian_dicodon_phase.hpp"
#define HAS_VERTEBRATE_MAMMALIAN_DICODON 1
#endif

#if __has_include("agp/vertebrate_other_dicodon_phase.hpp")
#include "agp/vertebrate_other_dicodon_phase.hpp"
#define HAS_VERTEBRATE_OTHER_DICODON 1
#endif

namespace agp {
namespace dicodon {

/**
 * Get phase-specific hexamer frequency for a domain
 *
 * @param code Encoded hexamer (0-4095)
 * @param phase Codon phase (0, 1, or 2)
 * @param domain Target domain
 * @return Frequency of hexamer at this phase
 */
inline float get_phase_freq(uint32_t code, int phase, Domain domain) {
    if (code >= 4096 || phase < 0 || phase > 2) return 1.0f / 4096.0f;

    // Default to uniform if domain tables not available
    constexpr float UNIFORM = 1.0f / 4096.0f;

    switch (domain) {
#ifdef HAS_GTDB_DICODON
        case Domain::GTDB:
            switch (phase) {
                case 0: return GTDB_PHASE0_HEXAMER_FREQ[code];
                case 1: return GTDB_PHASE1_HEXAMER_FREQ[code];
                case 2: return GTDB_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_FUNGI_DICODON
        case Domain::FUNGI:
            switch (phase) {
                case 0: return FUNGI_PHASE0_HEXAMER_FREQ[code];
                case 1: return FUNGI_PHASE1_HEXAMER_FREQ[code];
                case 2: return FUNGI_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_VIRAL_DICODON
        case Domain::VIRAL:
            switch (phase) {
                case 0: return VIRAL_PHASE0_HEXAMER_FREQ[code];
                case 1: return VIRAL_PHASE1_HEXAMER_FREQ[code];
                case 2: return VIRAL_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_PLANT_DICODON
        case Domain::PLANT:
            switch (phase) {
                case 0: return PLANT_PHASE0_HEXAMER_FREQ[code];
                case 1: return PLANT_PHASE1_HEXAMER_FREQ[code];
                case 2: return PLANT_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_PROTOZOA_DICODON
        case Domain::PROTOZOA:
            switch (phase) {
                case 0: return PROTOZOA_PHASE0_HEXAMER_FREQ[code];
                case 1: return PROTOZOA_PHASE1_HEXAMER_FREQ[code];
                case 2: return PROTOZOA_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_INVERTEBRATE_DICODON
        case Domain::INVERTEBRATE:
            switch (phase) {
                case 0: return INVERTEBRATE_PHASE0_HEXAMER_FREQ[code];
                case 1: return INVERTEBRATE_PHASE1_HEXAMER_FREQ[code];
                case 2: return INVERTEBRATE_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_VERTEBRATE_MAMMALIAN_DICODON
        case Domain::VERTEBRATE_MAMMALIAN:
            switch (phase) {
                case 0: return VERTEBRATE_MAMMALIAN_PHASE0_HEXAMER_FREQ[code];
                case 1: return VERTEBRATE_MAMMALIAN_PHASE1_HEXAMER_FREQ[code];
                case 2: return VERTEBRATE_MAMMALIAN_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
#ifdef HAS_VERTEBRATE_OTHER_DICODON
        case Domain::VERTEBRATE_OTHER:
            switch (phase) {
                case 0: return VERTEBRATE_OTHER_PHASE0_HEXAMER_FREQ[code];
                case 1: return VERTEBRATE_OTHER_PHASE1_HEXAMER_FREQ[code];
                case 2: return VERTEBRATE_OTHER_PHASE2_HEXAMER_FREQ[code];
            }
            break;
#endif
        default:
            break;
    }

    return UNIFORM;
}

/**
 * Calculate frame score using dicodon phase hexamers
 *
 * The key insight: if we're testing frame F, a hexamer at position i
 * would be at phase ((i - F) mod 3) in the true frame. The hexamer
 * at that position should match the phase 0 distribution if F is correct.
 *
 * Score = sum of log(P(hex | phase_expected) / P(hex | uniform))
 *
 * @param seq DNA sequence (uppercase preferred)
 * @param frame Reading frame to test (0, 1, or 2)
 * @param domain Target domain
 * @return Log-likelihood ratio score (higher = more likely this frame)
 */
inline float calculate_frame_score(const char* seq, size_t len, int frame, Domain domain) {
    if (len < 6 || frame < 0 || frame > 2) return 0.0f;

    float llr_sum = 0.0f;
    int count = 0;
    constexpr float UNIFORM = 1.0f / 4096.0f;
    constexpr float LOG_UNIFORM = -8.317766f;  // log(1/4096)

    // Score each hexamer position
    for (size_t i = 0; i + 5 < len; i++) {
        uint32_t code = encode_hexamer(seq + i);
        if (code >= 4096) continue;

        // What phase would this hexamer be in if 'frame' is the correct frame?
        // At position i, if true frame is 'frame', the codon phase is (i - frame + 300) % 3
        // The +300 ensures we don't go negative
        int expected_phase = (static_cast<int>(i) - frame + 300) % 3;

        // Get the frequency for this hexamer at the expected phase
        float freq = get_phase_freq(code, expected_phase, domain);

        if (freq > 1e-10f) {
            llr_sum += std::log(freq) - LOG_UNIFORM;
            count++;
        }
    }

    return count > 0 ? llr_sum / count : 0.0f;
}

/**
 * Calculate frame score using string interface
 */
inline float calculate_frame_score(const std::string& seq, int frame, Domain domain) {
    return calculate_frame_score(seq.c_str(), seq.length(), frame, domain);
}

// Alias for compatibility with optimized scorer
inline float calculate_frame_score_fast(const char* seq, int len, int frame, Domain domain) {
    return calculate_frame_score(seq, static_cast<size_t>(len), frame, domain);
}

/**
 * Calculate frame scores for all 3 frames and return the best
 *
 * @param seq DNA sequence
 * @param domain Target domain
 * @return Pair of (best_frame, confidence) where confidence = score[best] - score[second_best]
 */
inline std::pair<int, float> select_best_frame(const char* seq, size_t len, Domain domain) {
    float scores[3];
    scores[0] = calculate_frame_score(seq, len, 0, domain);
    scores[1] = calculate_frame_score(seq, len, 1, domain);
    scores[2] = calculate_frame_score(seq, len, 2, domain);

    int best = 0;
    if (scores[1] > scores[best]) best = 1;
    if (scores[2] > scores[best]) best = 2;

    // Find second best for confidence calculation
    float second_best = (best == 0) ? scores[1] : scores[0];
    for (int i = 0; i < 3; i++) {
        if (i != best && scores[i] > second_best) second_best = scores[i];
    }

    return {best, scores[best] - second_best};
}

/**
 * Calculate frame scores for all 3 frames
 *
 * @param seq DNA sequence
 * @param domain Target domain
 * @param scores_out Array of 3 floats to receive scores
 */
inline void calculate_all_frame_scores(const char* seq, size_t len, Domain domain, float* scores_out) {
    scores_out[0] = calculate_frame_score(seq, len, 0, domain);
    scores_out[1] = calculate_frame_score(seq, len, 1, domain);
    scores_out[2] = calculate_frame_score(seq, len, 2, domain);
}

/**
 * Get expected GC content at wobble position (codon position 3) for a domain
 *
 * This can be used as a frame discriminator since wobble position has distinct
 * nucleotide frequencies from positions 1 and 2.
 *
 * @param domain Target domain
 * @return Expected GC3 content (0.0 to 1.0)
 */
inline float get_expected_gc3(Domain domain) {
    switch (domain) {
#ifdef HAS_GTDB_DICODON
        case Domain::GTDB: return GTDB_GC3;
#endif
#ifdef HAS_FUNGI_DICODON
        case Domain::FUNGI: return FUNGI_GC3;
#endif
#ifdef HAS_VIRAL_DICODON
        case Domain::VIRAL: return VIRAL_GC3;
#endif
#ifdef HAS_PLANT_DICODON
        case Domain::PLANT: return PLANT_GC3;
#endif
#ifdef HAS_PROTOZOA_DICODON
        case Domain::PROTOZOA: return PROTOZOA_GC3;
#endif
#ifdef HAS_INVERTEBRATE_DICODON
        case Domain::INVERTEBRATE: return INVERTEBRATE_GC3;
#endif
#ifdef HAS_VERTEBRATE_MAMMALIAN_DICODON
        case Domain::VERTEBRATE_MAMMALIAN: return VERTEBRATE_MAMMALIAN_GC3;
#endif
#ifdef HAS_VERTEBRATE_OTHER_DICODON
        case Domain::VERTEBRATE_OTHER: return VERTEBRATE_OTHER_GC3;
#endif
        default: return 0.5f;  // Default to 50%
    }
}

/**
 * Check if dicodon phase data is available for a domain
 */
inline bool has_dicodon_data(Domain domain) {
    switch (domain) {
#ifdef HAS_GTDB_DICODON
        case Domain::GTDB: return true;
#endif
#ifdef HAS_FUNGI_DICODON
        case Domain::FUNGI: return true;
#endif
#ifdef HAS_VIRAL_DICODON
        case Domain::VIRAL: return true;
#endif
#ifdef HAS_PLANT_DICODON
        case Domain::PLANT: return true;
#endif
#ifdef HAS_PROTOZOA_DICODON
        case Domain::PROTOZOA: return true;
#endif
#ifdef HAS_INVERTEBRATE_DICODON
        case Domain::INVERTEBRATE: return true;
#endif
#ifdef HAS_VERTEBRATE_MAMMALIAN_DICODON
        case Domain::VERTEBRATE_MAMMALIAN: return true;
#endif
#ifdef HAS_VERTEBRATE_OTHER_DICODON
        case Domain::VERTEBRATE_OTHER: return true;
#endif
        default: return false;
    }
}

} // namespace dicodon
} // namespace agp
